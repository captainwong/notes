gnu Make notes
==============


## 0. 借助 `STM32CubeMX` 生成的 `Makefile` （有修改），向 `chatgpt` 学习

```makefile
##########################################################################################################################
# File automatically-generated by tool: [projectgenerator] version: [4.5.0-B34] date: [Wed Oct 09 10:58:11 CST 2024]
##########################################################################################################################

# ------------------------------------------------
# Generic Makefile (based on gcc)
#
# ChangeLog :
#	2017-02-10 - Several enhancements + project update mode
#   2015-07-22 - first version
# ------------------------------------------------

######################################
# target
######################################
TARGET = stm32_5100_hal
STLINK="C:/Program Files (x86)/STMicroelectronics/STM32 ST-LINK Utility/ST-LINK Utility/ST-LINK_CLI.exe"
STLINK_SN=E1007200D0D2139393740544

######################################
# building variables
######################################
# debug build?
DEBUG = 1
# optimization
OPT = -Og


#######################################
# paths
#######################################
# Build path
BUILD_DIR = build

######################################
# source
######################################
# C sources
C_SOURCES =  \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio_ex.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_tim_ex.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_rcc_ex.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_gpio.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_dma.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_cortex.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_pwr.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_flash.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_flash_ex.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_exti.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_iwdg.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_uart.c \
Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal_usart.c \
Core/Src/dma.c \
Core/Src/gpio.c \
Core/Src/iwdg.c \
Core/Src/main.c \
Core/Src/stm32f1xx_hal_msp.c \
Core/Src/stm32f1xx_it.c \
Core/Src/syscalls.c \
Core/Src/sysmem.c \
Core/Src/system_stm32f1xx.c \
Core/Src/tim.c \
Core/Src/usart.c

# ASM sources
ASM_SOURCES =  \
startup_stm32f103xb.s

# ASM sources
ASMM_SOURCES = 


#######################################
# binaries
#######################################
GCC_PATH ?= /D/gcc-arm-none-eabi-13.3-rel1/bin
PREFIX = arm-none-eabi-
# The gcc compiler bin path can be either defined in make command via GCC_PATH variable (> make GCC_PATH=xxx)
# either it can be added to the PATH environment variable.
ifdef GCC_PATH
CC = $(GCC_PATH)/$(PREFIX)gcc
AS = $(GCC_PATH)/$(PREFIX)gcc -x assembler-with-cpp
CP = $(GCC_PATH)/$(PREFIX)objcopy
SZ = $(GCC_PATH)/$(PREFIX)size
else
CC = $(PREFIX)gcc
AS = $(PREFIX)gcc -x assembler-with-cpp
CP = $(PREFIX)objcopy
SZ = $(PREFIX)size
endif
HEX = $(CP) -O ihex
BIN = $(CP) -O binary -S
 
#######################################
# CFLAGS
#######################################
# cpu
CPU = -mcpu=cortex-m3

# fpu
# NONE for Cortex-M0/M0+/M3

# float-abi


# mcu
MCU = $(CPU) -mthumb $(FPU) $(FLOAT-ABI)

# macros for gcc
# AS defines
AS_DEFS = 

# C defines
C_DEFS =  \
-DUSE_HAL_DRIVER \
-DSTM32F103xB


# AS includes
AS_INCLUDES = 

# C includes
C_INCLUDES =  \
-IH:/dev_hb/libhb/libhb \
-ICore/Inc \
-IDrivers/STM32F1xx_HAL_Driver/Inc \
-IDrivers/STM32F1xx_HAL_Driver/Inc/Legacy \
-IDrivers/CMSIS/Device/ST/STM32F1xx/Include \
-IDrivers/CMSIS/Include \
-IDrivers/BSP/Inc


# compile gcc flags
ASFLAGS = $(MCU) $(AS_DEFS) $(AS_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections

CFLAGS += $(MCU) $(C_DEFS) $(C_INCLUDES) $(OPT) -Wall -fdata-sections -ffunction-sections

ifeq ($(DEBUG), 1)
CFLAGS += -g -gdwarf-2
endif


# Generate dependency information
CFLAGS += -MMD -MP -MF"$(@:%.o=%.d)"


#######################################
# LDFLAGS
#######################################
# link script
LDSCRIPT = STM32F103C8Tx_FLASH.ld

# libraries
LIBS = -lc -lm -lnosys 
LIBDIR = 
LDFLAGS = $(MCU) -specs=nano.specs -T$(LDSCRIPT) $(LIBDIR) $(LIBS) -Wl,-Map=$(BUILD_DIR)/$(TARGET).map,--cref -Wl,--gc-sections

# default action: build all
all: $(BUILD_DIR)/$(TARGET).elf $(BUILD_DIR)/$(TARGET).hex $(BUILD_DIR)/$(TARGET).bin

flash: all
	${STLINK} -c SN=${STLINK_SN} SWD -P ${BUILD_DIR}/${TARGET}.hex -V -Rst


#######################################
# build the application
#######################################
# list of objects
OBJECTS = $(addprefix $(BUILD_DIR)/,$(notdir $(C_SOURCES:.c=.o)))
vpath %.c $(sort $(dir $(C_SOURCES)))
# list of ASM program objects
OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASM_SOURCES:.s=.o)))
vpath %.s $(sort $(dir $(ASM_SOURCES)))
OBJECTS += $(addprefix $(BUILD_DIR)/,$(notdir $(ASMM_SOURCES:.S=.o)))
vpath %.S $(sort $(dir $(ASMM_SOURCES)))

$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR) 
	$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(<:.c=.lst)) $< -o $@

$(BUILD_DIR)/%.o: %.s Makefile | $(BUILD_DIR)
	$(AS) -c $(CFLAGS) $< -o $@
$(BUILD_DIR)/%.o: %.S Makefile | $(BUILD_DIR)
	$(AS) -c $(CFLAGS) $< -o $@

$(BUILD_DIR)/$(TARGET).elf: $(OBJECTS) Makefile
	$(CC) $(OBJECTS) $(LDFLAGS) -o $@
	$(SZ) $@

$(BUILD_DIR)/%.hex: $(BUILD_DIR)/%.elf | $(BUILD_DIR)
	$(HEX) $< $@
	
$(BUILD_DIR)/%.bin: $(BUILD_DIR)/%.elf | $(BUILD_DIR)
	$(BIN) $< $@	
	./stat.sh $<
	
$(BUILD_DIR):
	mkdir $@

#######################################
# clean up
#######################################
clean:
	-rm -fR $(BUILD_DIR)
  
#######################################
# dependencies
#######################################
-include $(wildcard $(BUILD_DIR)/*.d)

.PHONY: all clean prepare flash

# *** EOF ***
```


## 1. `$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR)` 这一句Makefile代码，解释含义和 `|` 的用法

这段代码是GNU Makefile中的一部分，用于定义如何生成目标文件（`%.o`），其中包含了文件依赖关系以及Make的特殊语法。

---

### **代码分解：**
```makefile
$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR)
```

1. **`$(BUILD_DIR)/%.o`**  
   表示目标文件的模式规则，生成目标是在`$(BUILD_DIR)`目录下的`.o`文件。例如：
   - `src/main.c` 会生成 `build/main.o`。

2. **`%.c`**  
   表示依赖的源文件，也即规则的源文件模式。例如：
   - 如果目标是 `build/main.o`，则依赖于当前目录下的 `main.c` 文件。

3. **`Makefile`**  
   表示当前规则还依赖于 `Makefile` 文件本身。如果 `Makefile` 被修改，所有符合该规则的目标都会重新生成。

4. **`| $(BUILD_DIR)`**  
   这里的 `|` 是 **order-only prerequisite（仅顺序依赖）** 的符号，用于指示：  
   - `$(BUILD_DIR)` 是一个目录，不影响目标文件是否需要重建。  
   - 即使 `$(BUILD_DIR)` 发生了改变，也不会触发重新构建目标文件。

   **用途**：
   - 确保在生成目标文件之前，`$(BUILD_DIR)` 目录是存在的。
   - 避免目录的时间戳改变引起不必要的目标重建。

---

### **执行逻辑：**
1. 如果 `build/main.o` 不存在，或者其依赖的 `main.c` 或 `Makefile` 更新，Make会执行规则来生成 `build/main.o`。
2. 在执行规则之前，Make会检查 `$(BUILD_DIR)` 是否存在。如果不存在，则首先创建 `$(BUILD_DIR)`。

---

### **`|` 和常规依赖的对比：**
假设我们没有使用 `|`，而是像这样：
```makefile
$(BUILD_DIR)/%.o: %.c Makefile $(BUILD_DIR)
```
这种写法将 `$(BUILD_DIR)` 作为普通依赖：
- 如果 `$(BUILD_DIR)` 的时间戳更新，Make会重新构建目标文件。
- 这通常是不必要的，因为目录的时间戳变化并不会影响目标文件的内容。

而使用 `|` 可以避免这个问题，简化依赖关系，同时确保目录的存在。

---

### **完整示例：**
以下是一个完整的Makefile示例：
```makefile
BUILD_DIR = build
SRC_FILES = main.c utils.c
OBJ_FILES = $(SRC_FILES:%.c=$(BUILD_DIR)/%.o)

$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR)
	$(CC) -c $< -o $@

$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

all: $(OBJ_FILES)
	$(CC) $(OBJ_FILES) -o my_program

clean:
	rm -rf $(BUILD_DIR) my_program
```

---

### **总结：**
- `|` 用于声明 **order-only prerequisite**，确保目录存在但不影响目标重建。
- 这是一种优雅且高效的方式来管理构建目录，避免因目录时间戳变动导致不必要的构建。

## 2. BUILD_DIR 既是变量，又是标号，有点迷惑了

在 Makefile 中，`BUILD_DIR` 是一个变量，而不是标号（Label）。但由于 Makefile 的写法允许将变量名和规则定义组合在一起，可能会让你感到混淆。下面解释清楚这两种场景的作用，以及为什么它不会冲突。

---

### **`BUILD_DIR` 是变量**
在 Makefile 中，`BUILD_DIR` 通常是一个变量，用来表示构建目录。例如：
```makefile
BUILD_DIR = build
```
这段代码将变量 `BUILD_DIR` 定义为 `build`。你可以通过 `$(BUILD_DIR)` 使用它。例如：
```makefile
$(BUILD_DIR)/main.o
```
表示生成的目标文件路径为 `build/main.o`。

---

### **`$(BUILD_DIR):` 是目标**
在 Makefile 中，如果写成：
```makefile
$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)
```
这定义了一个构建规则，表示如何创建 `BUILD_DIR` 目录。  
这里的 `$(BUILD_DIR)` 被解析为 `build`，所以等价于：
```makefile
build:
	mkdir -p build
```

在这种情况下，`$(BUILD_DIR):` 是一个目标（Target），表示这个规则的目标文件或目录是 `build`。

---

### **为什么不会冲突？**
1. **变量解析与规则定义分开**  
   - `BUILD_DIR = build` 定义了一个变量，`$(BUILD_DIR)` 会在后续使用时被替换为 `build`。
   - `$(BUILD_DIR):` 是一个规则，它的目标名称是变量 `$(BUILD_DIR)` 的值，也就是 `build`。
   - 变量名和目标是不同的层次概念，Make 能够正确解析它们，不会冲突。

2. **Makefile 的解析顺序**  
   - 在解析规则时，Make 会先替换变量名再进行后续处理。
   - 例如，`$(BUILD_DIR)/%.o` 会被解析成 `build/%.o`，而 `$(BUILD_DIR):` 会被解析为 `build:`。

---

### **示例解析**
结合以下代码来理解：
```makefile
BUILD_DIR = build
SRC = main.c utils.c
OBJS = $(SRC:%.c=$(BUILD_DIR)/%.o)

$(BUILD_DIR)/%.o: %.c
	mkdir -p $(BUILD_DIR)
	$(CC) -c $< -o $@

$(BUILD_DIR):
	mkdir -p $(BUILD_DIR)

all: $(OBJS)
	$(CC) $(OBJS) -o my_program
```

#### **变量解析：**
- `$(BUILD_DIR)` 的值是 `build`，所以 `$(BUILD_DIR)/%.o` 会被替换成 `build/%.o`。
- 变量 `$(OBJS)` 最终会变成：`build/main.o build/utils.o`。

#### **目标解析：**
- `$(BUILD_DIR):` 会被解析为 `build:`，这是一个独立的规则，表示如何生成或准备 `build` 目录。
- `$(BUILD_DIR)/%.o:` 会被解析为 `build/%.o:`，表示 `build/` 目录下的所有 `.o` 文件如何生成。

#### **执行流程：**
1. 运行 `make all`：
   - 检查 `build` 目录是否存在。如果不存在，会执行 `mkdir -p build`。
2. 根据依赖关系，生成 `build/main.o` 和 `build/utils.o`。
3. 最后，链接生成最终的 `my_program`。

---

### **总结**
在 Makefile 中，`BUILD_DIR` 是变量，`$(BUILD_DIR):` 是一个基于变量值的目标规则。  
它们虽然都使用了同一个名字，但因为作用和解析阶段不同，不会冲突。Makefile 的灵活性允许这种写法，以简化代码和维护。


## 3. 解释 179-185行中 vpath 的语法

### **179-185 行中的 `vpath` 语法解释**

在 GNU Make 中，`vpath` 是用于指定文件搜索路径的关键字。它的作用是告诉 Make 在特定目录中查找某种模式的文件。如果源文件位于不同目录而非当前工作目录，通过 `vpath` 可以避免手动拼接路径。

```makefile
vpath %.c $(sort $(dir $(C_SOURCES)))
vpath %.s $(sort $(dir $(ASM_SOURCES)))
vpath %.S $(sort $(dir $(ASMM_SOURCES)))
```

#### **语法解释**
1. **`vpath`**  
   - GNU Make 提供的指令，用于设置文件搜索路径。
   - 基本语法：
     ```makefile
     vpath <pattern> <directory list>
     ```
     - `<pattern>`：匹配文件的模式，例如 `%.c` 表示所有以 `.c` 结尾的文件。
     - `<directory list>`：包含此类文件的目录列表（可以是多个目录，用空格分隔）。

2. **`%.c`、`%.s`、`%.S`**  
   - 这些是 Make 的通配符，表示所有 `.c`、`.s` 或 `.S` 文件。
   - `%` 是通配符，匹配文件名的任意部分。

3. **`$(sort $(dir ...))`**  
   - `$(dir $(C_SOURCES))`：提取变量 `C_SOURCES` 中每个文件的目录路径。
     - 例如：`Drivers/STM32F1xx_HAL_Driver/Src/stm32f1xx_hal.c` 的目录是 `Drivers/STM32F1xx_HAL_Driver/Src/`。
   - `$(sort ...)`：对目录列表去重并排序，防止重复路径。

---

### **代码执行含义**
这些 `vpath` 定义了 Make 查找文件的策略：
- **`vpath %.c $(sort $(dir $(C_SOURCES)))`**  
  Make 在 `$(C_SOURCES)` 中所有 `.c` 文件的目录中查找符合规则的目标。
  
- **`vpath %.s $(sort $(dir $(ASM_SOURCES)))`**  
  Make 在 `$(ASM_SOURCES)` 中所有 `.s` 文件的目录中查找符合规则的目标。

- **`vpath %.S $(sort $(dir $(ASMM_SOURCES)))`**  
  Make 在 `$(ASMM_SOURCES)` 中所有 `.S` 文件的目录中查找符合规则的目标。

---

### **实际用途**
在构建流程中，源文件经常分布在多个子目录中。`vpath` 的作用是减少路径硬编码，提高 Makefile 的可维护性。  
例如：
- 当编译规则中指定：
  ```makefile
  $(BUILD_DIR)/%.o: %.c
  ```
  - `%.c` 只是文件名而无完整路径。
  - 通过 `vpath`，Make 会自动在 `$(C_SOURCES)` 所指定的目录中查找对应的 `.c` 文件。

没有 `vpath` 时，需要手动为每个源文件提供完整路径。

---

### **总结**
179-185 行通过 `vpath` 配置，告诉 Make 在源文件的各自目录中查找对应类型的文件，避免重复指定路径。`vpath` 提高了 Makefile 的灵活性和可维护性，是处理多目录项目的常用工具。


## 4. 211行是什么意思，以及 *.d 文件是何时生成的

### **211 行解释**

```makefile
-include $(wildcard $(BUILD_DIR)/*.d)
```

#### **作用**
1. **`$(wildcard $(BUILD_DIR)/*.d)`**  
   - 使用 `wildcard` 函数查找 `$(BUILD_DIR)` 目录下的所有 `.d` 文件，并生成一个文件列表。
   - 例如，假设 `$(BUILD_DIR)` 是 `build`，则 `wildcard` 会查找 `build` 中的所有 `.d` 文件，生成类似 `build/main.d build/gpio.d` 的文件列表。

2. **`-include`**  
   - 强制 Make 包含指定文件列表中的每个文件的内容。
   - 前面的 `-` 表示 **忽略错误**，即如果文件不存在，不会导致 Make 失败。
   - 这些 `.d` 文件通常是依赖文件，记录了 `.o` 文件的构建规则依赖项（例如哪些头文件参与了构建）。

3. **整体行为**  
   - Make 会动态加载 `.d` 文件，以自动处理源文件的依赖项变化。
   - 如果 `.d` 文件不存在（比如第一次运行 `make` 时），由于 `-` 前缀，Make 会忽略错误并继续执行构建。

---

### **`.d` 文件的生成**

#### **`.d` 文件是什么**
`.d` 文件是依赖文件，通常是由 GCC 自动生成的。它们记录了每个目标文件（`.o`）的依赖关系，包括头文件的路径。

例如，`build/main.d` 可能包含如下内容：
```makefile
build/main.o: main.c gpio.h stm32f1xx_hal.h
```

这表示 `main.o` 依赖于 `main.c` 和 `gpio.h` 等头文件。当这些文件中的任何一个发生变化时，`main.o` 都需要重新生成。

---

#### **`.d` 文件的生成时机**
在 Makefile 中，`.d` 文件通常通过以下选项在编译阶段生成：
```makefile
CFLAGS += -MMD -MP -MF"$(@:%.o=%.d)"
```

- **`-MMD`**  
  - 指示 GCC 生成依赖文件，但不要包含系统头文件（通常是 `/usr/include` 下的文件）。
  
- **`-MP`**  
  - 为防止在依赖文件中引用的头文件被删除后导致错误，生成 "伪目标" 条目。例如：
    ```makefile
    gpio.h:
    ```
    这样即使 `gpio.h` 文件被删除，也不会导致 Make 失败。

- **`-MF"$(@:%.o=%.d)"`**  
  - 指定依赖文件的文件名。
  - `$(@:%.o=%.d)`：将目标文件（如 `main.o`）的后缀 `.o` 替换为 `.d`，生成 `main.d`。

---

#### **生成时机的实例**
假设有一条编译规则如下：
```makefile
$(BUILD_DIR)/%.o: %.c Makefile | $(BUILD_DIR)
	$(CC) -c $(CFLAGS) -Wa,-a,-ad,-alms=$(BUILD_DIR)/$(notdir $(<:.c=.lst)) $< -o $@
```

- 当 GCC 编译 `main.c` 时，`-MMD -MP -MF` 选项会自动生成 `build/main.d` 文件，记录 `main.o` 的依赖关系。

---

### **总结**

1. **211 行含义**  
   - 自动包含构建目录中所有 `.d` 文件，以动态追踪文件依赖关系。
   - 通过 `-` 确保即使 `.d` 文件不存在（比如首次构建），构建过程仍能正常运行。

2. **`.d` 文件生成的时机**  
   - 编译 `.c` 文件为 `.o` 文件时，由 GCC 的 `-MMD` 等选项自动生成。  
   - `.d` 文件是为了管理目标与头文件的依赖关系，确保在头文件更新时触发目标的重建。


