# AT Command Server Tutorial

Generated by `Claude Sonnet 4` for the [cAT](https://github.com/marcinbor85/cAT) library.

## Table of Contents
1. [What are AT Commands?](#what-are-at-commands)
2. [Introduction to cAT Library](#introduction-to-cat-library)
3. [Basic Setup](#basic-setup)
4. [The Five Types of AT Commands](#the-five-types-of-at-commands)
5. [Variables and Data Types](#variables-and-data-types)
6. [Advanced Mechanisms](#advanced-mechanisms)
7. [Complete Examples](#complete-examples)
8. [Best Practices](#best-practices)

---

## What are AT Commands?

**AT Commands** (Attention Commands) are text-based commands originally developed for controlling modems. Today, they're widely used in IoT devices, cellular modules, WiFi modules, and embedded systems for configuration and control.

### Basic AT Command Format

```
AT[+CMD][operation][parameters]
```

**Examples:**
- `AT` - Basic attention command
- `AT+WIFI=connect,"MyNetwork","password"` - Connect to WiFi
- `AT+STATUS?` - Query device status
- `AT+RESET` - Reset device

### Why Use AT Commands?

1. **Standardized**: Widely recognized interface
2. **Human-readable**: Easy to debug and test
3. **Simple**: Text-based, no complex protocols
4. **Flexible**: Can handle various data types and operations
5. **Tool-friendly**: Works with terminal programs, scripts, and automation

---

## Introduction to cAT Library

The **cAT library** is a lightweight, non-blocking AT command parser designed for embedded systems. It helps you create AT command servers that can:

- Parse incoming AT commands
- Validate parameters automatically
- Generate appropriate responses
- Handle asynchronous operations
- Manage unsolicited notifications

### Key Features

- **100% static memory allocation** - No malloc/free
- **Non-blocking operation** - Character-by-character parsing
- **Multiple command types** - READ, WRITE, RUN, TEST
- **Automatic response formatting** - Built-in help and error handling
- **Variable mapping** - Automatic parameter parsing and validation
- **Asynchronous support** - Hold mechanism for long operations
- **Unsolicited responses** - Send notifications anytime

---

## Basic Setup

### 1. Include the Library

```c
#include "cat.h"
```

### 2. Define I/O Interface

The library needs functions to read and write characters:

```c
// Your UART/Serial write function
static int write_char(char ch) {
    // Send character to UART/USB/etc
    uart_send_byte(ch);
    return 1;  // Return 1 if successful
}

// Your UART/Serial read function  
static int read_char(char* ch) {
    if (uart_has_data()) {
        *ch = uart_receive_byte();
        return 1;  // Return 1 if character available
    }
    return 0;  // Return 0 if no data
}

static struct cat_io_interface io_interface = {
    .read = read_char,
    .write = write_char
};
```

### 3. Create Working Buffer

```c
static char working_buffer[256];  // Adjust size as needed
```

### 4. Define Commands and Descriptor

```c
static struct cat_command commands[] = {
    // Commands will be defined here
};

static struct cat_command_group cmd_group = {
    .cmd = commands,
    .cmd_num = sizeof(commands) / sizeof(commands[0]),
};

static struct cat_command_group* cmd_groups[] = {&cmd_group};

static struct cat_descriptor descriptor = {
    .cmd_group = cmd_groups,
    .cmd_group_num = sizeof(cmd_groups) / sizeof(cmd_groups[0]),
    .buf = (uint8_t*)working_buffer,
    .buf_size = sizeof(working_buffer),
};
```

### 5. Initialize and Run

```c
struct cat_object at_parser;

int main(void) {
    // Initialize the AT command parser
    cat_init(&at_parser, &descriptor, &io_interface, NULL);
    
    // Main loop
    while (1) {
        cat_service(&at_parser);  // Process AT commands
        
        // Your other application code here
        // The parser is non-blocking!
    }
}
```

---

## The Five Types of AT Commands

### 1. TEST Commands (`AT+CMD=?`)

**Purpose**: Show command format and help information

**User types**: `AT+WIFI=?`  
**Response**: 
```
+WIFI=<SSID:STRING[RW]>,<PASSWORD:STRING[WO]>
Connect to WiFi network
OK
```

**Implementation**:
```c
static cat_return_state wifi_test(const struct cat_command* cmd, 
                                  uint8_t* data, size_t* data_size, 
                                  const size_t max_data_size) {
    // Custom test response (optional)
    // The library automatically generates format from variables
    return CAT_RETURN_STATE_OK;
}

static struct cat_command wifi_cmd = {
    .name = "+WIFI",
    .description = "Connect to WiFi network",
    .test = wifi_test,  // Optional - automatic if variables defined
    .var = wifi_variables,
    .var_num = 2,
};
```

### 2. READ Commands (`AT+CMD?`)

**Purpose**: Query current values/status

**User types**: `AT+WIFI?`  
**Response**: 
```
+WIFI="MyNetwork","connected"
OK
```

**Implementation**:
```c
static char current_ssid[32] = "MyNetwork";
static char connection_status[16] = "connected";

static struct cat_variable wifi_read_vars[] = {
    {.type = CAT_VAR_BUF_STRING, .data = current_ssid, 
     .data_size = sizeof(current_ssid), .name = "SSID",
     .access = CAT_VAR_ACCESS_READ_ONLY},
    {.type = CAT_VAR_BUF_STRING, .data = connection_status,
     .data_size = sizeof(connection_status), .name = "STATUS", 
     .access = CAT_VAR_ACCESS_READ_ONLY},
};

static cat_return_state wifi_read(const struct cat_command* cmd,
                                  uint8_t* data, size_t* data_size,
                                  const size_t max_data_size) {
    // Update status before reading (optional)
    update_connection_status();
    return CAT_RETURN_STATE_OK;  // Use automatic variable formatting
}

static struct cat_command wifi_cmd = {
    .name = "+WIFI",
    .read = wifi_read,
    .var = wifi_read_vars,
    .var_num = 2,
};
```

### 3. WRITE Commands (`AT+CMD=value`)

**Purpose**: Set values or trigger actions with parameters

**User types**: `AT+WIFI="NewNetwork","mypassword"`  
**Response**: 
```
OK
```

**Implementation**:
```c
static char target_ssid[32];
static char target_password[64];

static struct cat_variable wifi_write_vars[] = {
    {.type = CAT_VAR_BUF_STRING, .data = target_ssid,
     .data_size = sizeof(target_ssid), .name = "SSID",
     .access = CAT_VAR_ACCESS_WRITE_ONLY},
    {.type = CAT_VAR_BUF_STRING, .data = target_password,
     .data_size = sizeof(target_password), .name = "PASSWORD",
     .access = CAT_VAR_ACCESS_WRITE_ONLY},
};

static cat_return_state wifi_write(const struct cat_command* cmd,
                                   const uint8_t* data, const size_t data_size,
                                   const size_t args_num) {
    // Variables are already parsed and stored in target_ssid/target_password
    printf("Connecting to: %s\n", target_ssid);
    
    // Start WiFi connection
    if (start_wifi_connection(target_ssid, target_password) == 0) {
        return CAT_RETURN_STATE_OK;
    } else {
        return CAT_RETURN_STATE_ERROR;
    }
}

static struct cat_command wifi_cmd = {
    .name = "+WIFI",
    .write = wifi_write,
    .var = wifi_write_vars,
    .var_num = 2,
    .need_all_vars = true,  // Both SSID and password required
};
```

### 4. RUN Commands (`AT+CMD`)

**Purpose**: Execute actions without parameters

**User types**: `AT+RESET`  
**Response**: 
```
OK
```

**Implementation**:
```c
static cat_return_state reset_run(const struct cat_command* cmd) {
    printf("Resetting device...\n");
    
    // Trigger system reset
    system_reset();
    
    return CAT_RETURN_STATE_OK;
}

static struct cat_command reset_cmd = {
    .name = "+RESET",
    .description = "Reset the device",
    .run = reset_run,
};
```

### 5. IMPLICIT WRITE Commands (`ATCMD` without `=`)

**Purpose**: Legacy modem-style commands where everything after command name is data

**User types**: `ATDT1234567890`  
**Response**: 
```
OK
```

**Implementation**:
```c
static cat_return_state dial_write(const struct cat_command* cmd,
                                   const uint8_t* data, const size_t data_size,
                                   const size_t args_num) {
    // data contains "1234567890" as raw string
    char phone_number[32];
    memcpy(phone_number, data, data_size);
    phone_number[data_size] = '\0';
    
    printf("Dialing: %s\n", phone_number);
    start_phone_call(phone_number);
    
    return CAT_RETURN_STATE_OK;
}

static struct cat_command dial_cmd = {
    .name = "DT",           // User types: ATDT1234567890
    .write = dial_write,
    .implicit_write = true, // Everything after "DT" becomes data
    // Note: Cannot have read, run, or test handlers with implicit_write
};
```

---

## Variables and Data Types

Variables provide automatic parameter parsing and validation.

### Variable Types

```c
typedef enum {
    CAT_VAR_INT_DEC,     // Signed decimal: -123, 456
    CAT_VAR_UINT_DEC,    // Unsigned decimal: 123, 456  
    CAT_VAR_NUM_HEX,     // Hexadecimal: 0x1A, 0xFF
    CAT_VAR_BUF_HEX,     // Hex bytes: DEADBEEF
    CAT_VAR_BUF_STRING   // Quoted string: "hello"
} cat_var_type;
```

### Access Control

```c
typedef enum {
    CAT_VAR_ACCESS_READ_WRITE,  // Can read and write
    CAT_VAR_ACCESS_READ_ONLY,   // Only show in read commands
    CAT_VAR_ACCESS_WRITE_ONLY,  // Only accept in write commands
} cat_var_access;
```

### Example: Complete Variable Definition

```c
static int32_t volume = 50;          // Current volume level
static uint8_t bass = 5;             // Bass level 0-10
static char eq_preset[16] = "rock";  // EQ preset name

static int volume_write(const struct cat_variable* var, const size_t write_size) {
    // Called after volume is updated
    if (volume < 0 || volume > 100) {
        return -1;  // Reject invalid values
    }
    
    set_hardware_volume(volume);
    printf("Volume set to: %d\n", volume);
    return 0;  // Accept
}

static int bass_write(const struct cat_variable* var, const size_t write_size) {
    if (bass > 10) {
        return -1;  // Reject
    }
    
    set_hardware_bass(bass);
    return 0;
}

static struct cat_variable audio_vars[] = {
    {
        .name = "VOLUME",
        .type = CAT_VAR_INT_DEC,
        .data = &volume,
        .data_size = sizeof(volume),
        .access = CAT_VAR_ACCESS_READ_WRITE,
        .write = volume_write,  // Validation callback
    },
    {
        .name = "BASS", 
        .type = CAT_VAR_UINT_DEC,
        .data = &bass,
        .data_size = sizeof(bass),
        .access = CAT_VAR_ACCESS_READ_WRITE,
        .write = bass_write,
    },
    {
        .name = "PRESET",
        .type = CAT_VAR_BUF_STRING,
        .data = eq_preset,
        .data_size = sizeof(eq_preset),
        .access = CAT_VAR_ACCESS_READ_WRITE,
    },
};

static struct cat_command audio_cmd = {
    .name = "+AUDIO",
    .description = "Audio control",
    .var = audio_vars,
    .var_num = 3,
};
```

**Usage Examples:**
- `AT+AUDIO=?` → Shows format with all variables
- `AT+AUDIO?` → Shows current values: `+AUDIO=50,5,"rock"`
- `AT+AUDIO=75,8,"jazz"` → Sets all three values
- `AT+AUDIO=60` → Sets only volume (if need_all_vars = false)

---

## Advanced Mechanisms

### Hold Mechanism (Asynchronous Operations)

The hold mechanism allows commands to complete asynchronously - perfect for network operations, file I/O, or hardware initialization that takes time.

#### How It Works

1. Command handler returns `CAT_RETURN_STATE_HOLD`
2. Parser enters "hold state" - no immediate response
3. Operation continues in background
4. When complete, call `cat_hold_exit()` or return `CAT_RETURN_STATE_HOLD_EXIT_*`
5. Parser sends final `OK` or `ERROR` response

#### Example: WiFi Connection with Timeout

```c
static struct {
    bool connecting;
    uint32_t start_time;
    char ssid[32];
} wifi_state = {0};

static cat_return_state wifi_connect_write(const struct cat_command* cmd,
                                           const uint8_t* data, 
                                           const size_t data_size,
                                           const size_t args_num) {
    // Start connection process
    strcpy(wifi_state.ssid, target_ssid);
    wifi_state.connecting = true;
    wifi_state.start_time = get_time_ms();
    
    start_wifi_connection_async(target_ssid, target_password);
    
    return CAT_RETURN_STATE_HOLD;  // Don't respond yet
}

// Called from main loop
void check_wifi_status(void) {
    if (!wifi_state.connecting) return;
    
    uint32_t elapsed = get_time_ms() - wifi_state.start_time;
    
    if (wifi_is_connected()) {
        printf("Connected to %s\n", wifi_state.ssid);
        wifi_state.connecting = false;
        cat_hold_exit(&at_parser, CAT_STATUS_OK);  // Send "OK"
        
    } else if (elapsed > 10000) {  // 10 second timeout
        printf("Connection timeout\n");
        wifi_state.connecting = false;
        cat_hold_exit(&at_parser, CAT_STATUS_ERROR);  // Send "ERROR"
    }
}

int main(void) {
    cat_init(&at_parser, &descriptor, &io_interface, NULL);
    
    while (1) {
        cat_service(&at_parser);
        check_wifi_status();  // Check async operations
        
        // Other tasks...
    }
}
```

#### Alternative: Hold Exit from Callback

```c
static cat_return_state file_operation_read(const struct cat_command* cmd,
                                            uint8_t* data, size_t* data_size,
                                            const size_t max_data_size) {
    static int call_count = 0;
    
    if (call_count == 0) {
        // First call - start operation
        start_file_read_async();
        call_count++;
        return CAT_RETURN_STATE_HOLD;  // Enter hold
    }
    
    // Subsequent calls - check if complete
    if (file_operation_complete()) {
        call_count = 0;
        if (file_operation_success()) {
            // Format response data
            sprintf((char*)data, "File size: %d bytes", get_file_size());
            *data_size = strlen((char*)data);
            return CAT_RETURN_STATE_HOLD_EXIT_OK;  // Exit with data + OK
        } else {
            return CAT_RETURN_STATE_HOLD_EXIT_ERROR;  // Exit with ERROR
        }
    }
    
    return CAT_RETURN_STATE_HOLD;  // Still waiting
}
```

### Unsolicited Response Mechanism

Unsolicited responses allow your device to send notifications or data without being asked - like incoming calls, sensor readings, or status changes.

#### Example: Sensor Monitoring

```c
// Define the notification command
static int temperature = 25;
static int humidity = 60;

static struct cat_variable sensor_vars[] = {
    {.name = "TEMP", .type = CAT_VAR_INT_DEC, .data = &temperature,
     .data_size = sizeof(temperature), .access = CAT_VAR_ACCESS_READ_ONLY},
    {.name = "HUMIDITY", .type = CAT_VAR_INT_DEC, .data = &humidity,
     .data_size = sizeof(humidity), .access = CAT_VAR_ACCESS_READ_ONLY},
};

static struct cat_command sensor_notification = {
    .name = "+SENSOR",
    .var = sensor_vars,
    .var_num = 2,
    .only_test = true,  // Only for unsolicited use
};

// Update sensor readings
void update_sensors(void) {
    int new_temp = read_temperature();
    int new_humidity = read_humidity();
    
    if (abs(new_temp - temperature) > 2 || abs(new_humidity - humidity) > 5) {
        temperature = new_temp;
        humidity = new_humidity;
        
        // Send unsolicited notification
        cat_trigger_unsolicited_read(&at_parser, &sensor_notification);
    }
}

int main(void) {
    cat_init(&at_parser, &descriptor, &io_interface, NULL);
    
    while (1) {
        cat_service(&at_parser);
        
        static uint32_t last_sensor_check = 0;
        if (get_time_ms() - last_sensor_check > 1000) {  // Every second
            update_sensors();
            last_sensor_check = get_time_ms();
        }
    }
}
```

**Output when temperature changes:**
```
+SENSOR=27,65
```

#### Example: Multiple Scan Results

```c
static struct scan_result {
    int rssi;
    char ssid[32];
} scan_results[10];

static int scan_count = 0;
static int scan_index = 0;

static cat_return_state scan_read(const struct cat_command* cmd,
                                  uint8_t* data, size_t* data_size,
                                  const size_t max_data_size) {
    if (scan_index >= scan_count) {
        return CAT_RETURN_STATE_HOLD_EXIT_OK;  // Done
    }
    
    // Load current result into variables
    current_rssi = scan_results[scan_index].rssi;
    strcpy(current_ssid, scan_results[scan_index].ssid);
    
    scan_index++;
    
    if (scan_index < scan_count) {
        // More results coming
        cat_trigger_unsolicited_read(&at_parser, cmd);
        return CAT_RETURN_STATE_DATA_NEXT;
    } else {
        // This is the last result
        return CAT_RETURN_STATE_DATA_OK;
    }
}

static cat_return_state start_scan_write(const struct cat_command* cmd,
                                         const uint8_t* data,
                                         const size_t data_size,
                                         const size_t args_num) {
    // Perform scan
    scan_count = wifi_scan(scan_results, 10);
    scan_index = 0;
    
    if (scan_count > 0) {
        // Load first result
        current_rssi = scan_results[0].rssi;
        strcpy(current_ssid, scan_results[0].ssid);
        scan_index = 1;
        
        // Trigger first response
        cat_trigger_unsolicited_read(&at_parser, &scan_result_cmd);
        return CAT_RETURN_STATE_HOLD;
    } else {
        return CAT_RETURN_STATE_ERROR;  // No networks found
    }
}
```

**Output:**
```
AT+SCAN
+SCAN=-45,"HomeWiFi"
+SCAN=-67,"OfficeNet"  
+SCAN=-72,"PublicWiFi"
OK
```

### Other Important Mechanisms

#### Command Groups

Organize related commands:

```c
static struct cat_command wifi_commands[] = {
    {.name = "+WIFICONNECT", .write = wifi_connect_write},
    {.name = "+WIFISCAN", .write = wifi_scan_write},
    {.name = "+WIFISTATUS", .read = wifi_status_read},
};

static struct cat_command system_commands[] = {
    {.name = "+RESET", .run = system_reset},
    {.name = "+VERSION", .read = version_read},
    {.name = "+INFO", .read = system_info_read},
};

static struct cat_command_group wifi_group = {
    .name = "WiFi Commands",
    .cmd = wifi_commands,
    .cmd_num = 3,
};

static struct cat_command_group system_group = {
    .name = "System Commands", 
    .cmd = system_commands,
    .cmd_num = 3,
};

static struct cat_command_group* all_groups[] = {
    &wifi_group,
    &system_group,
};
```

#### Command List Feature

Add a help command that lists all available commands:

```c
static cat_return_state help_run(const struct cat_command* cmd) {
    return CAT_RETURN_STATE_PRINT_CMD_LIST_OK;
}

static struct cat_command help_cmd = {
    .name = "#HELP",
    .description = "Show all available commands",
    .run = help_run,
};
```

**Output:**
```
AT#HELP

AT+WIFICONNECT=
AT+WIFICONNECT=?
AT+WIFISCAN
AT+WIFISCAN=?
AT+RESET
AT+VERSION?
AT+VERSION=?
...
OK
```

#### Disabling Commands

```c
static struct cat_command debug_cmd = {
    .name = "+DEBUG",
    .write = debug_write,
    .disable = !IS_DEBUG_BUILD,  // Conditional compilation
};

static struct cat_command_group debug_group = {
    .name = "Debug Commands",
    .cmd = debug_commands,
    .cmd_num = 5,
    .disable = !IS_DEBUG_BUILD,  // Disable entire group
};
```

---

## Complete Examples

### Example 1: Smart Thermostat

```c
#include "cat.h"
#include <stdio.h>
#include <string.h>

// Device state
static int target_temperature = 22;
static int current_temperature = 20;
static bool heating_on = false;
static char mode[16] = "auto";

// Temperature control variables
static struct cat_variable temp_vars[] = {
    {.name = "TARGET", .type = CAT_VAR_INT_DEC, .data = &target_temperature,
     .data_size = sizeof(target_temperature), .access = CAT_VAR_ACCESS_READ_WRITE},
    {.name = "CURRENT", .type = CAT_VAR_INT_DEC, .data = &current_temperature,
     .data_size = sizeof(current_temperature), .access = CAT_VAR_ACCESS_READ_ONLY},
    {.name = "HEATING", .type = CAT_VAR_UINT_DEC, .data = &heating_on,
     .data_size = sizeof(heating_on), .access = CAT_VAR_ACCESS_READ_ONLY},
};

// Mode control variables
static struct cat_variable mode_vars[] = {
    {.name = "MODE", .type = CAT_VAR_BUF_STRING, .data = mode,
     .data_size = sizeof(mode), .access = CAT_VAR_ACCESS_READ_WRITE},
};

// Temperature status notification
static struct cat_variable temp_alert_vars[] = {
    {.name = "TEMP", .type = CAT_VAR_INT_DEC, .data = &current_temperature,
     .data_size = sizeof(current_temperature), .access = CAT_VAR_ACCESS_READ_ONLY},
    {.name = "ALERT", .type = CAT_VAR_BUF_STRING, .data = "CHANGED",
     .data_size = 8, .access = CAT_VAR_ACCESS_READ_ONLY},
};

// Command implementations
static cat_return_state temp_write(const struct cat_command* cmd,
                                   const uint8_t* data, const size_t data_size,
                                   const size_t args_num) {
    if (target_temperature < 10 || target_temperature > 30) {
        return CAT_RETURN_STATE_ERROR;
    }
    
    printf("Target temperature set to: %d°C\n", target_temperature);
    return CAT_RETURN_STATE_OK;
}

static cat_return_state mode_write(const struct cat_command* cmd,
                                   const uint8_t* data, const size_t data_size,
                                   const size_t args_num) {
    if (strcmp(mode, "auto") != 0 && strcmp(mode, "heat") != 0 && 
        strcmp(mode, "cool") != 0 && strcmp(mode, "off") != 0) {
        return CAT_RETURN_STATE_ERROR;
    }
    
    printf("Mode changed to: %s\n", mode);
    return CAT_RETURN_STATE_OK;
}

static cat_return_state reset_run(const struct cat_command* cmd) {
    target_temperature = 22;
    strcpy(mode, "auto");
    heating_on = false;
    printf("Thermostat reset to defaults\n");
    return CAT_RETURN_STATE_OK;
}

// Commands
static struct cat_command commands[] = {
    {
        .name = "+TEMP",
        .description = "Temperature control",
        .write = temp_write,
        .var = temp_vars,
        .var_num = 3,
    },
    {
        .name = "+MODE", 
        .description = "Operating mode (auto/heat/cool/off)",
        .write = mode_write,
        .var = mode_vars,
        .var_num = 1,
    },
    {
        .name = "+RESET",
        .description = "Reset to factory defaults", 
        .run = reset_run,
    },
};

// Notification command (not in main command list)
static struct cat_command temp_alert_cmd = {
    .name = "+TEMPALERT",
    .var = temp_alert_vars,
    .var_num = 2,
    .only_test = true,
};

// Standard setup
static char buffer[256];
static struct cat_command_group cmd_group = {
    .cmd = commands,
    .cmd_num = sizeof(commands) / sizeof(commands[0]),
};
static struct cat_command_group* cmd_groups[] = {&cmd_group};
static struct cat_descriptor descriptor = {
    .cmd_group = cmd_groups,
    .cmd_group_num = 1,
    .buf = (uint8_t*)buffer,
    .buf_size = sizeof(buffer),
};

// I/O functions (implement for your platform)
static int write_char(char ch) {
    putchar(ch);  // Replace with UART write
    return 1;
}

static int read_char(char* ch) {
    // Replace with UART read
    // Return 1 if character available, 0 if not
    return 0;  // Simplified for example
}

static struct cat_io_interface io_interface = {
    .read = read_char,
    .write = write_char
};

// Thermostat logic
void update_thermostat(void) {
    static int last_temp = -999;
    
    // Simulate reading temperature sensor
    // current_temperature = read_temperature_sensor();
    
    // Control heating
    if (strcmp(mode, "heat") == 0 || strcmp(mode, "auto") == 0) {
        if (current_temperature < target_temperature - 1) {
            heating_on = true;
        } else if (current_temperature >= target_temperature) {
            heating_on = false;
        }
    } else {
        heating_on = false;
    }
    
    // Send notification if temperature changed significantly
    if (abs(current_temperature - last_temp) >= 2) {
        cat_trigger_unsolicited_read(&at_parser, &temp_alert_cmd);
        last_temp = current_temperature;
    }
}

static struct cat_object at_parser;

int main(void) {
    cat_init(&at_parser, &descriptor, &io_interface, NULL);
    
    printf("Smart Thermostat AT Interface\n");
    printf("Try: AT+TEMP=25 or AT+MODE=\"heat\"\n");
    
    while (1) {
        cat_service(&at_parser);
        update_thermostat();
        
        // Add delay for your system
        // delay_ms(100);
    }
    
    return 0;
}
```

### Example 2: IoT Sensor Node

```c
#include "cat.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// Sensor data
static float temperature = 23.5;
static float humidity = 45.2;
static int light_level = 750;
static bool motion_detected = false;

// Configuration
static int report_interval = 30;  // seconds
static bool auto_report = true;

// Status
static char device_id[16] = "SENSOR001";
static char version[16] = "1.2.3";
static uint32_t uptime = 0;

// Read sensor command variables
static struct cat_variable sensor_vars[] = {
    {.name = "TEMP", .type = CAT_VAR_INT_DEC, .data = &temperature,
     .data_size = sizeof(int), .access = CAT_VAR_ACCESS_READ_ONLY},
    {.name = "HUMIDITY", .type = CAT_VAR_INT_DEC, .data = &humidity,
     .data_size = sizeof(int), .access = CAT_VAR_ACCESS_READ_ONLY},
    {.name = "LIGHT", .type = CAT_VAR_INT_DEC, .data = &light_level,
     .data_size = sizeof(light_level), .access = CAT_VAR_ACCESS_READ_ONLY},
    {.name = "MOTION", .type = CAT_VAR_UINT_DEC, .data = &motion_detected,
     .data_size = sizeof(motion_detected), .access = CAT_VAR_ACCESS_READ_ONLY},
};

// Configuration variables
static struct cat_variable config_vars[] = {
    {.name = "INTERVAL", .type = CAT_VAR_INT_DEC, .data = &report_interval,
     .data_size = sizeof(report_interval), .access = CAT_VAR_ACCESS_READ_WRITE},
    {.name = "AUTO", .type = CAT_VAR_UINT_DEC, .data = &auto_report,
     .data_size = sizeof(auto_report), .access = CAT_VAR_ACCESS_READ_WRITE},
};

// Status variables  
static struct cat_variable status_vars[] = {
    {.name = "ID", .type = CAT_VAR_BUF_STRING, .data = device_id,
     .data_size = sizeof(device_id), .access = CAT_VAR_ACCESS_READ_ONLY},
    {.name = "VERSION", .type = CAT_VAR_BUF_STRING, .data = version,
     .data_size = sizeof(version), .access = CAT_VAR_ACCESS_READ_ONLY},
    {.name = "UPTIME", .type = CAT_VAR_UINT_DEC, .data = &uptime,
     .data_size = sizeof(uptime), .access = CAT_VAR_ACCESS_READ_ONLY},
};

// Command handlers
static int config_write_handler(const struct cat_variable* var, const size_t write_size) {
    if (strcmp(var->name, "INTERVAL") == 0) {
        if (report_interval < 1 || report_interval > 3600) {
            return -1;  // Invalid range
        }
        printf("Report interval set to %d seconds\n", report_interval);
    }
    return 0;
}

static cat_return_state calibrate_run(const struct cat_command* cmd) {
    printf("Calibrating sensors...\n");
    
    // Simulate calibration process with hold
    return CAT_RETURN_STATE_HOLD;
}

// Unsolicited notification commands
static struct cat_command sensor_notification = {
    .name = "+SENSORDATA",
    .var = sensor_vars,
    .var_num = 4,
    .only_test = true,
};

static struct cat_command motion_notification = {
    .name = "+MOTION",
    .only_test = true,
};

// Main commands
static struct cat_command commands[] = {
    {
        .name = "+SENSOR",
        .description = "Read all sensors",
        .var = sensor_vars,
        .var_num = 4,
    },
    {
        .name = "+CONFIG",
        .description = "Device configuration", 
        .var = config_vars,
        .var_num = 2,
    },
    {
        .name = "+STATUS",
        .description = "Device status information",
        .var = status_vars,
        .var_num = 3,
    },
    {
        .name = "+CALIBRATE",
        .description = "Calibrate sensors",
        .run = calibrate_run,
    },
};

// Setup (same pattern as before)
static char buffer[512];
static struct cat_command_group cmd_group = {
    .cmd = commands,
    .cmd_num = sizeof(commands) / sizeof(commands[0]),
};
static struct cat_command_group* cmd_groups[] = {&cmd_group};
static struct cat_descriptor descriptor = {
    .cmd_group = cmd_groups,
    .cmd_group_num = 1,
    .buf = (uint8_t*)buffer,
    .buf_size = sizeof(buffer),
};

static struct cat_object at_parser;

// Application logic
static uint32_t last_report_time = 0;
static bool calibration_in_progress = false;
static uint32_t calibration_start_time = 0;

void read_sensors(void) {
    // Simulate sensor readings
    temperature = 20.0 + (rand() % 100) / 10.0;  // 20-30°C
    humidity = 40.0 + (rand() % 300) / 10.0;     // 40-70%
    light_level = 100 + rand() % 900;             // 100-1000 lux
    
    // Convert float to int for AT interface
    *(int*)sensor_vars[0].data = (int)(temperature * 10);  // x10 for precision
    *(int*)sensor_vars[1].data = (int)(humidity * 10);
}

void check_motion(void) {
    static bool last_motion = false;
    
    // Simulate motion detection
    motion_detected = (rand() % 100) < 5;  // 5% chance each check
    
    if (motion_detected && !last_motion) {
        // Motion started - send notification
        cat_trigger_unsolicited_read(&at_parser, &motion_notification);
    }
    
    last_motion = motion_detected;
}

void handle_auto_reporting(void) {
    uint32_t current_time = uptime;
    
    if (auto_report && 
        (current_time - last_report_time) >= report_interval) {
        read_sensors();
        cat_trigger_unsolicited_read(&at_parser, &sensor_notification);
        last_report_time = current_time;
    }
}

void handle_calibration(void) {
    if (!calibration_in_progress) return;
    
    // Simulate 5-second calibration
    if ((uptime - calibration_start_time) >= 5) {
        printf("Calibration complete!\n");
        calibration_in_progress = false;
        cat_hold_exit(&at_parser, CAT_STATUS_OK);
    }
}

// I/O functions (implement for your platform)
static int write_char(char ch) {
    putchar(ch);
    return 1;
}

static int read_char(char* ch) {
    // Implement UART read
    return 0;  // No data for this example
}

static struct cat_io_interface io_interface = {
    .read = read_char,
    .write = write_char
};

int main(void) {
    // Initialize variables
    config_vars[0].write = config_write_handler;
    
    cat_init(&at_parser, &descriptor, &io_interface, NULL);
    
    printf("IoT Sensor Node v%s\n", version);
    printf("Device ID: %s\n", device_id);
    printf("Commands: AT+SENSOR?, AT+CONFIG?, AT+STATUS?\n");
    
    while (1) {
        cat_service(&at_parser);
        
        // Update uptime (simulate 1 second per loop)
        uptime++;
        
        read_sensors();
        check_motion();
        handle_auto_reporting();
        handle_calibration();
        
        // Add proper delay for your system
        // delay_ms(1000);
    }
    
    return 0;
}
```

---

## Best Practices

### 1. Error Handling

```c
static cat_return_state safe_write_handler(const struct cat_command* cmd,
                                           const uint8_t* data,
                                           const size_t data_size,
                                           const size_t args_num) {
    // Validate input
    if (data_size == 0) {
        return CAT_RETURN_STATE_ERROR;
    }
    
    // Check system state
    if (!system_ready()) {
        return CAT_RETURN_STATE_ERROR;
    }
    
    // Try operation
    if (perform_operation(data, data_size) != 0) {
        return CAT_RETURN_STATE_ERROR;
    }
    
    return CAT_RETURN_STATE_OK;
}

static int validate_variable(const struct cat_variable* var, const size_t write_size) {
    // Range checking
    if (var->type == CAT_VAR_INT_DEC) {
        int value = *(int*)var->data;
        if (value < MIN_VALUE || value > MAX_VALUE) {
            printf("Value %d out of range [%d, %d]\n", value, MIN_VALUE, MAX_VALUE);
            return -1;
        }
    }
    
    // String validation
    if (var->type == CAT_VAR_BUF_STRING) {
        if (write_size >= var->data_size) {
            printf("String too long\n");
            return -1;
        }
    }
    
    return 0;
}
```

### 2. Memory Management

```c
// Use appropriate buffer sizes
#define AT_BUFFER_SIZE 256    // Adjust based on longest expected command

// Consider command count for bit-packed state storage
// Buffer size should be: (number_of_commands / 4) + command_args_space
#define MAX_COMMANDS 20
#define REQUIRED_BUFFER_SIZE ((MAX_COMMANDS / 4) + 200)

static char at_buffer[REQUIRED_BUFFER_SIZE];
```

### 3. Thread Safety

```c
// If using RTOS, provide mutex interface
static int mutex_lock(void) {
    return xSemaphoreTake(at_mutex, portMAX_DELAY) == pdTRUE ? 0 : -1;
}

static int mutex_unlock(void) {
    return xSemaphoreGive(at_mutex) == pdTRUE ? 0 : -1;
}

static struct cat_mutex_interface mutex_interface = {
    .lock = mutex_lock,
    .unlock = mutex_unlock
};

// Initialize with mutex
cat_init(&at_parser, &descriptor, &io_interface, &mutex_interface);
```

### 4. Debugging and Logging

```c
#ifdef DEBUG_AT_COMMANDS
static int debug_write_char(char ch) {
    printf("AT_OUT: %c (0x%02X)\n", ch, ch);
    return uart_write_char(ch);
}

static int debug_read_char(char* ch) {
    int result = uart_read_char(ch);
    if (result) {
        printf("AT_IN: %c (0x%02X)\n", *ch, *ch);
    }
    return result;
}
#endif

// Log command execution
static cat_return_state logged_command(const struct cat_command* cmd, ...) {
    printf("Executing command: %s\n", cmd->name);
    
    cat_return_state result = actual_command_implementation(cmd, ...);
    
    printf("Command %s result: %d\n", cmd->name, result);
    return result;
}
```

### 5. Command Organization

```c
// Group related commands
static struct cat_command wifi_commands[] = { /* ... */ };
static struct cat_command bluetooth_commands[] = { /* ... */ };
static struct cat_command system_commands[] = { /* ... */ };

// Use descriptive names
static struct cat_command commands[] = {
    {.name = "+WIFI_CONNECT", .write = wifi_connect},      // Clear purpose
    {.name = "+WIFI_SCAN", .write = wifi_scan},
    {.name = "+BT_PAIR", .write = bluetooth_pair},
    {.name = "+SYS_RESET", .run = system_reset},
    {.name = "+SYS_INFO", .read = system_info},
};

// Provide good descriptions
{
    .name = "+WIFI",
    .description = "WiFi control: SSID[string], PASSWORD[string], TIMEOUT[int]",
    .write = wifi_connect,
    // ...
}
```

### 6. Testing

```c
// Create test commands for development
#ifdef ENABLE_TEST_COMMANDS
static cat_return_state test_sensors(const struct cat_command* cmd) {
    printf("Testing all sensors...\n");
    run_sensor_self_test();
    return CAT_RETURN_STATE_OK;
}

static cat_return_state simulate_error(const struct cat_command* cmd) {
    printf("Simulating error condition\n");
    return CAT_RETURN_STATE_ERROR;
}

static struct cat_command test_commands[] = {
    {.name = "#TEST_SENSORS", .run = test_sensors},
    {.name = "#SIMULATE_ERROR", .run = simulate_error},
};
#endif
```

---

## Conclusion

The cAT library provides a powerful foundation for building AT command interfaces in embedded systems. Key advantages:

- **Non-blocking architecture** - Integrates well with main application loops
- **Automatic parsing** - Variables handle parameter validation and conversion
- **Flexible response patterns** - Immediate, delayed (hold), and unsolicited responses
- **Memory efficient** - Static allocation with bit-packed command state tracking
- **Extensible** - Easy to add new commands and features

Start with simple READ/WRITE commands, then add RUN commands for actions, TEST commands for help, and finally implement hold and unsolicited mechanisms for advanced functionality.

The library handles the complex AT command parsing protocol details, letting you focus on your application logic and user experience.